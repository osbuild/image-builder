// Package server provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi"
	"net/http"
	"strings"
)

// Compose defines model for Compose.
type Compose struct {
	Architecture string       `json:"architecture"`
	Distribution string       `json:"distribution"`
	ImageType    string       `json:"image_type"`
	Repositories []Repository `json:"repositories"`
}

// ComposeRequest defines model for ComposeRequest.
type ComposeRequest struct {
	ImageBuilds []Compose `json:"image_builds"`
}

// ComposeResponse defines model for ComposeResponse.
type ComposeResponse struct {
	ComposeId string `json:"compose_id"`
}

// ComposeStatus defines model for ComposeStatus.
type ComposeStatus struct {
	Status string `json:"status"`
}

// Repository defines model for Repository.
type Repository struct {
	Baseurl string `json:"baseurl"`
}

// Version defines model for Version.
type Version struct {
	Version string `json:"version"`
}

// ComposeImageJSONBody defines parameters for ComposeImage.
type ComposeImageJSONBody ComposeRequest

// ComposeImageRequestBody defines body for ComposeImage for application/json ContentType.
type ComposeImageJSONRequestBody ComposeImageJSONBody

type ServerInterface interface {
	// compose image (POST /compose)
	ComposeImage(w http.ResponseWriter, r *http.Request)
	// get status of an image compose (GET /compose/{composeId})
	GetComposeStatus(w http.ResponseWriter, r *http.Request)
	// get the openapi json specification (GET /openapi.json)
	GetOpenapiJson(w http.ResponseWriter, r *http.Request)
	// get the service version (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ComposeImage operation middleware
func ComposeImageCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetComposeStatus operation middleware
func GetComposeStatusCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var err error

		// ------------- Path parameter "composeId" -------------
		var composeId string

		err = runtime.BindStyledParameter("simple", false, "composeId", chi.URLParam(r, "composeId"), &composeId)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter composeId: %s", err), http.StatusBadRequest)
			return
		}

		ctx = context.WithValue(ctx, "composeId", composeId)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetOpenapiJson operation middleware
func GetOpenapiJsonCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetVersion operation middleware
func GetVersionCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerFromMux(si, chi.NewRouter())
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	r.Group(func(r chi.Router) {
		r.Use(ComposeImageCtx)
		r.Post("/compose", si.ComposeImage)
	})
	r.Group(func(r chi.Router) {
		r.Use(GetComposeStatusCtx)
		r.Get("/compose/{composeId}", si.GetComposeStatus)
	})
	r.Group(func(r chi.Router) {
		r.Use(GetOpenapiJsonCtx)
		r.Get("/openapi.json", si.GetOpenapiJson)
	})
	r.Group(func(r chi.Router) {
		r.Use(GetVersionCtx)
		r.Get("/version", si.GetVersion)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/7RVwU7rOhD9FWveW4ak8HbZvYfQU6+uLhJIbFCF3GTaGCWx8UxAFcq/X9mxS9JEhcVl",
	"Z3XGx2fOOZO+Q6Ebo1tsmSB/ByoqbKQ/XrsCoTsaqw1aVugL0haVYiy4s77KB4OQA7FV7R76BErlztuO",
	"lW4XG1Qj9/g0/LxQtmg0KdY2PKgYG3/42+IOcvgr+yCdBcbZXbx0cBABU1orD9B7zJdOWSwhf5zyS6bz",
	"TMidUNn0SVTlDl86JJ6LM9zedqouv849Sv0Z8Qn45tist89YMIzZkdHtknfF0PCkygXlT14b9Y4mv2fJ",
	"Hc2R6fj7edTQ5xBHls3gtpKws/XneLFxSY4HtBQyOEV//SicR4+Nm95VVLvT7k6JVFhlhnzDPdpXVaDg",
	"SrKwWMsDCe+U8E4JO2SFIIFaFRh8aWXj3v3XyKJCcZWuIAE/MFTMhvIse3t7S6Uvp9rus3CXsp/r65tf",
	"9zcXV+kqrbipfWwU1w7ulvybF6ollnWNVtDADpKPoeHSXdEGW2kU5PBPukovIQEjufLyZMVo9/UQ8+nM",
	"oWGYEzyYla62LiGPUVmHYhDgP10ehgy2jK0HlcbUqvAXs2caDBmW4osrE/fQ2zOlWCJLVZPQu+AGa7FF",
	"EZiXMDaabYfe+WFvvAhXq9WfZxv2coFuVLSSJIilZSx9GqlrGuk25ERzV4s+Ze/hsC57R2WPC5YNi+fk",
	"kG1QJNp86t//yNNtd9mwskFGS5A/nkKvSwcb+YWHWAvHw20N5D5bkMTUH+nOXEhGip6u5ub7HQrznvGH",
	"YsfYmj2yOKOv9yrsWxp5BZNmyt8OfT/I/zktDTwlZpE725LgSpEoddE1Tow5P65QBA7CcRBksFC7IBck",
	"wHLvzIUGWboPXgLZ6Du5mKmIGz4yIvYvBOrhWPo2D+MTC+7JGcVlgeZdff87AAD//2L3RwkkCQAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
